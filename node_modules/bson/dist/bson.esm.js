import { Buffer } from 'buffer';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (b.hasOwnProperty(p)) d[p] = b[p];
    }
  };

  return _extendStatics(d, b);
};

function __extends(d, b) {
  _extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var _assign = function __assign() {
  _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return _assign.apply(this, arguments);
};

/** @public */
var BSONError = /** @class */ (function (_super) {
    __extends(BSONError, _super);
    function BSONError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, BSONError.prototype);
        return _this;
    }
    Object.defineProperty(BSONError.prototype, "name", {
        get: function () {
            return 'BSONError';
        },
        enumerable: false,
        configurable: true
    });
    return BSONError;
}(Error));
/** @public */
var BSONTypeError = /** @class */ (function (_super) {
    __extends(BSONTypeError, _super);
    function BSONTypeError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, BSONTypeError.prototype);
        return _this;
    }
    Object.defineProperty(BSONTypeError.prototype, "name", {
        get: function () {
            return 'BSONTypeError';
        },
        enumerable: false,
        configurable: true
    });
    return BSONTypeError;
}(TypeError));

function checkForMath(potentialGlobal) {
    // eslint-disable-next-line eqeqeq
    return potentialGlobal && potentialGlobal.Math == Math && potentialGlobal;
}
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
function getGlobal() {
    return (checkForMath(typeof globalThis === 'object' && globalThis) ||
        checkForMath(typeof window === 'object' && window) ||
        checkForMath(typeof self === 'object' && self) ||
        checkForMath(typeof global === 'object' && global) ||
        // eslint-disable-next-line @typescript-eslint/no-implied-eval
        Function('return this')());
}

/**
 * Normalizes our expected stringified form of a function across versions of node
 * @param fn - The function to stringify
 */
function normalizedFunctionString(fn) {
    return fn.toString().replace('function(', 'function (');
}
function isReactNative() {
    var g = getGlobal();
    return typeof g.navigator === 'object' && g.navigator.product === 'ReactNative';
}
var insecureRandomBytes = function insecureRandomBytes(size) {
    var insecureWarning = isReactNative()
        ? 'BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.'
        : 'BSON: No cryptographic implementation for random bytes present, falling back to a less secure implementation.';
    console.warn(insecureWarning);
    var result = Buffer.alloc(size);
    for (var i = 0; i < size; ++i)
        result[i] = Math.floor(Math.random() * 256);
    return result;
};
var detectRandomBytes = function () {
    {
        var requiredRandomBytes = void 0;
        try {
            requiredRandomBytes = require('crypto').randomBytes;
        }
        catch (e) {
            // keep the fallback
        }
        // NOTE: in transpiled cases the above require might return null/undefined
        return requiredRandomBytes || insecureRandomBytes;
    }
};
var randomBytes = detectRandomBytes();
function isAnyArrayBuffer(value) {
    return ['[object ArrayBuffer]', '[object SharedArrayBuffer]'].includes(Object.prototype.toString.call(value));
}
function isUint8Array(value) {
    return Object.prototype.toString.call(value) === '[object Uint8Array]';
}
function isBigInt64Array(value) {
    return Object.prototype.toString.call(value) === '[object BigInt64Array]';
}
function isBigUInt64Array(value) {
    return Object.prototype.toString.call(value) === '[object BigUint64Array]';
}
function isRegExp(d) {
    return Object.prototype.toString.call(d) === '[object RegExp]';
}
function isMap(d) {
    return Object.prototype.toString.call(d) === '[object Map]';
}
// To ensure that 0.4 of node works correctly
function isDate(d) {
    return isObjectLike(d) && Object.prototype.toString.call(d) === '[object Date]';
}
/**
 * @internal
 * this is to solve the `'someKey' in x` problem where x is unknown.
 * https://github.com/typescript-eslint/typescript-eslint/issues/1071#issuecomment-541955753
 */
function isObjectLike(candidate) {
    return typeof candidate === 'object' && candidate !== null;
}
function deprecate(fn, message) {
    var warned = false;
    function deprecated() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!warned) {
            console.warn(message);
            warned = true;
        }
        return fn.apply(this, args);
    }
    return deprecated;
}

/**
 * Makes sure that, if a Uint8Array is passed in, it is wrapped in a Buffer.
 *
 * @param potentialBuffer - The potential buffer
 * @returns Buffer the input if potentialBuffer is a buffer, or a buffer that
 * wraps a passed in Uint8Array
 * @throws BSONTypeError If anything other than a Buffer or Uint8Array is passed in
 */
function ensureBuffer(potentialBuffer) {
    if (ArrayBuffer.isView(potentialBuffer)) {
        return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
    }
    if (isAnyArrayBuffer(potentialBuffer)) {
        return Buffer.from(potentialBuffer);
    }
    throw new BSONTypeError('Must use either Buffer or TypedArray');
}

// Validation regex for v4 uuid (validates with or without dashes)
var VALIDATION_REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|[0-9a-f]{12}4[0-9a-f]{3}[89ab][0-9a-f]{15})$/i;
var uuidValidateString = function (str) {
    return typeof str === 'string' && VALIDATION_REGEX.test(str);
};
var uuidHexStringToBuffer = function (hexString) {
    if (!uuidValidateString(hexString)) {
        throw new BSONTypeError('UUID string representations must be a 32 or 36 character hex string (dashes excluded/included). Format: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" or "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".');
    }
    var sanitizedHexString = hexString.replace(/-/g, '');
    return Buffer.from(sanitizedHexString, 'hex');
};
var bufferToUuidHexString = function (buffer, includeDashes) {
    if (includeDashes === void 0) { includeDashes = true; }
    return includeDashes
        ? buffer.toString('hex', 0, 4) +
            '-' +
            buffer.toString('hex', 4, 6) +
            '-' +
            buffer.toString('hex', 6, 8) +
            '-' +
            buffer.toString('hex', 8, 10) +
            '-' +
            buffer.toString('hex', 10, 16)
        : buffer.toString('hex');
};

/** @internal */
var BSON_INT32_MAX$1 = 0x7fffffff;
/** @internal */
var BSON_INT32_MIN$1 = -0x80000000;
/** @internal */
var BSON_INT64_MAX$1 = Math.pow(2, 63) - 1;
/** @internal */
var BSON_INT64_MIN$1 = -Math.pow(2, 63);
/**
 * Any integer up to 2^53 can be precisely represented by a double.
 * @internal
 */
var JS_INT_MAX = Math.pow(2, 53);
/**
 * Any integer down to -2^53 can be precisely represented by a double.
 * @internal
 */
var JS_INT_MIN = -Math.pow(2, 53);
/** Number BSON Type @internal */
var BSON_DATA_NUMBER = 1;
/** String BSON Type @internal */
var BSON_DATA_STRING = 2;
/** Object BSON Type @internal */
var BSON_DATA_OBJECT = 3;
/** Array BSON Type @internal */
var BSON_DATA_ARRAY = 4;
/** Binary BSON Type @internal */
var BSON_DATA_BINARY = 5;
/** Binary BSON Type @internal */
var BSON_DATA_UNDEFINED = 6;
/** ObjectId BSON Type @internal */
var BSON_DATA_OID = 7;
/** Boolean BSON Type @internal */
var BSON_DATA_BOOLEAN = 8;
/** Date BSON Type @internal */
var BSON_DATA_DATE = 9;
/** null BSON Type @internal */
var BSON_DATA_NULL = 10;
/** RegExp BSON Type @internal */
var BSON_DATA_REGEXP = 11;
/** Code BSON Type @internal */
var BSON_DATA_DBPOINTER = 12;
/** Code BSON Type @internal */
var BSON_DATA_CODE = 13;
/** Symbol BSON Type @internal */
var BSON_DATA_SYMBOL = 14;
/** Code with Scope BSON Type @internal */
var BSON_DATA_CODE_W_SCOPE = 15;
/** 32 bit Integer BSON Type @internal */
var BSON_DATA_INT = 16;
/** Timestamp BSON Type @internal */
var BSON_DATA_TIMESTAMP = 17;
/** Long BSON Type @internal */
var BSON_DATA_LONG = 18;
/** Decimal128 BSON Type @internal */
var BSON_DATA_DECIMAL128 = 19;
/** MinKey BSON Type @internal */
var BSON_DATA_MIN_KEY = 0xff;
/** MaxKey BSON Type @internal */
var BSON_DATA_MAX_KEY = 0x7f;
/** Binary Default Type @internal */
var BSON_BINARY_SUBTYPE_DEFAULT = 0;
/** Binary Function Type @internal */
var BSON_BINARY_SUBTYPE_FUNCTION = 1;
/** Binary Byte Array Type @internal */
var BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
/** Binary Deprecated UUID Type @deprecated Please use BSON_BINARY_SUBTYPE_UUID_NEW @internal */
var BSON_BINARY_SUBTYPE_UUID = 3;
/** Binary UUID Type @internal */
var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
/** Binary MD5 Type @internal */
var BSON_BINARY_SUBTYPE_MD5 = 5;
/** Encrypted BSON type @internal */
var BSON_BINARY_SUBTYPE_ENCRYPTED = 6;
/** Column BSON type @internal */
var BSON_BINARY_SUBTYPE_COLUMN = 7;
/** Binary User Defined Type @internal */
var BSON_BINARY_SUBTYPE_USER_DEFINED = 128;

/**
 * A class representation of the BSON Binary type.
 * @public
 * @category BSONType
 */
var Binary = /** @class */ (function () {
    /**
     * Create a new Binary instance.
     *
     * This constructor can accept a string as its first argument. In this case,
     * this string will be encoded using ISO-8859-1, **not** using UTF-8.
     * This is almost certainly not what you want. Use `new Binary(Buffer.from(string))`
     * instead to convert the string to a Buffer using UTF-8 first.
     *
     * @param buffer - a buffer object containing the binary data.
     * @param subType - the option binary type.
     */
    function Binary(buffer, subType) {
        if (!(this instanceof Binary))
            return new Binary(buffer, subType);
        if (!(buffer == null) &&
            !(typeof buffer === 'string') &&
            !ArrayBuffer.isView(buffer) &&
            !(buffer instanceof ArrayBuffer) &&
            !Array.isArray(buffer)) {
            throw new BSONTypeError('Binary can only be constructed from string, Buffer, TypedArray, or Array<number>');
        }
        this.sub_type = subType !== null && subType !== void 0 ? subType : Binary.BSON_BINARY_SUBTYPE_DEFAULT;
        if (buffer == null) {
            // create an empty binary buffer
            this.buffer = Buffer.alloc(Binary.BUFFER_SIZE);
            this.position = 0;
        }
        else {
            if (typeof buffer === 'string') {
                // string
                this.buffer = Buffer.from(buffer, 'binary');
            }
            else if (Array.isArray(buffer)) {
                // number[]
                this.buffer = Buffer.from(buffer);
            }
            else {
                // Buffer | TypedArray | ArrayBuffer
                this.buffer = ensureBuffer(buffer);
            }
            this.position = this.buffer.byteLength;
        }
    }
    /**
     * Updates this binary with byte_value.
     *
     * @param byteValue - a single byte we wish to write.
     */
    Binary.prototype.put = function (byteValue) {
        // If it's a string and a has more than one character throw an error
        if (typeof byteValue === 'string' && byteValue.length !== 1) {
            throw new BSONTypeError('only accepts single character String');
        }
        else if (typeof byteValue !== 'number' && byteValue.length !== 1)
            throw new BSONTypeError('only accepts single character Uint8Array or Array');
        // Decode the byte value once
        var decodedByte;
        if (typeof byteValue === 'string') {
            decodedByte = byteValue.charCodeAt(0);
        }
        else if (typeof byteValue === 'number') {
            decodedByte = byteValue;
        }
        else {
            decodedByte = byteValue[0];
        }
        if (decodedByte < 0 || decodedByte > 255) {
            throw new BSONTypeError('only accepts number in a valid unsigned byte range 0-255');
        }
        if (this.buffer.length > this.position) {
            this.buffer[this.position++] = decodedByte;
        }
        else {
            var buffer = Buffer.alloc(Binary.BUFFER_SIZE + this.buffer.length);
            // Combine the two buffers together
            this.buffer.copy(buffer, 0, 0, this.buffer.length);
            this.buffer = buffer;
            this.buffer[this.position++] = decodedByte;
        }
    };
    /**
     * Writes a buffer or string to the binary.
     *
     * @param sequence - a string or buffer to be written to the Binary BSON object.
     * @param offset - specify the binary of where to write the content.
     */
    Binary.prototype.write = function (sequence, offset) {
        offset = typeof offset === 'number' ? offset : this.position;
        // If the buffer is to small let's extend the buffer
        if (this.buffer.length < offset + sequence.length) {
            var buffer = Buffer.alloc(this.buffer.length + sequence.length);
            this.buffer.copy(buffer, 0, 0, this.buffer.length);
            // Assign the new buffer
            this.buffer = buffer;
        }
        if (ArrayBuffer.isView(sequence)) {
            this.buffer.set(ensureBuffer(sequence), offset);
            this.position =
                offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
        }
        else if (typeof sequence === 'string') {
            this.buffer.write(sequence, offset, sequence.length, 'binary');
            this.position =
                offset + sequence.length > this.position ? offset + sequence.length : this.position;
        }
    };
    /**
     * Reads **length** bytes starting at **position**.
     *
     * @param position - read from the given position in the Binary.
     * @param length - the number of bytes to read.
     */
    Binary.prototype.read = function (position, length) {
        length = length && length > 0 ? length : this.position;
        // Let's return the data based on the type we have
        return this.buffer.slice(position, position + length);
    };
    /**
     * Returns the value of this binary as a string.
     * @param asRaw - Will skip converting to a string
     * @remarks
     * This is handy when calling this function conditionally for some key value pairs and not others
     */
    Binary.prototype.value = function (asRaw) {
        asRaw = !!asRaw;
        // Optimize to serialize for the situation where the data == size of buffer
        if (asRaw && this.buffer.length === this.position) {
            return this.buffer;
        }
        // If it's a node.js buffer object
        if (asRaw) {
            return this.buffer.slice(0, this.position);
        }
        return this.buffer.toString('binary', 0, this.position);
    };
    /** the length of the binary sequence */
    Binary.prototype.length = function () {
        return this.position;
    };
    Binary.prototype.toJSON = function () {
        return this.buffer.toString('base64');
    };
    Binary.prototype.toString = function (format) {
        return this.buffer.toString(format);
    };
    /** @internal */
    Binary.prototype.toExtendedJSON = function (options) {
        options = options || {};
        var base64String = this.buffer.toString('base64');
        var subType = Number(this.sub_type).toString(16);
        if (options.legacy) {
            return {
                $binary: base64String,
                $type: subType.length === 1 ? '0' + subType : subType
            };
        }
        return {
            $binary: {
                base64: base64String,
                subType: subType.length === 1 ? '0' + subType : subType
            }
        };
    };
    Binary.prototype.toUUID = function () {
        if (this.sub_type === Binary.SUBTYPE_UUID) {
            return new UUID(this.buffer.slice(0, this.position));
        }
        throw new BSONError("Binary sub_type \"".concat(this.sub_type, "\" is not supported for converting to UUID. Only \"").concat(Binary.SUBTYPE_UUID, "\" is currently supported."));
    };
    /** @internal */
    Binary.fromExtendedJSON = function (doc, options) {
        options = options || {};
        var data;
        var type;
        if ('$binary' in doc) {
            if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {
                type = doc.$type ? parseInt(doc.$type, 16) : 0;
                data = Buffer.from(doc.$binary, 'base64');
            }
            else {
                if (typeof doc.$binary !== 'string') {
                    type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
                    data = Buffer.from(doc.$binary.base64, 'base64');
                }
            }
        }
        else if ('$uuid' in doc) {
            type = 4;
            data = uuidHexStringToBuffer(doc.$uuid);
        }
        if (!data) {
            throw new BSONTypeError("Unexpected Binary Extended JSON format ".concat(JSON.stringify(doc)));
        }
        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);
    };
    /** @internal */
    Binary.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {
        return this.inspect();
    };
    Binary.prototype.inspect = function () {
        var asBuffer = this.value(true);
        return "new Binary(Buffer.from(\"".concat(asBuffer.toString('hex'), "\", \"hex\"), ").concat(this.sub_type, ")");
    };
    /**
     * Binary default subtype
     * @internal
     */
    Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    /** Initial buffer default size */
    Binary.BUFFER_SIZE = 256;
    /** Default BSON type */
    Binary.SUBTYPE_DEFAULT = 0;
    /** Function BSON type */
    Binary.SUBTYPE_FUNCTION = 1;
    /** Byte Array BSON type */
    Binary.SUBTYPE_BYTE_ARRAY = 2;
    /** Deprecated UUID BSON type @deprecated Please use SUBTYPE_UUID */
    Binary.SUBTYPE_UUID_OLD = 3;
    /** UUID BSON type */
    Binary.SUBTYPE_UUID = 4;
    /** MD5 BSON type */
    Binary.SUBTYPE_MD5 = 5;
    /** Encrypted BSON type */
    Binary.SUBTYPE_ENCRYPTED = 6;
    /** Column BSON type */
    Binary.SUBTYPE_COLUMN = 7;
    /** User BSON type */
    Binary.SUBTYPE_USER_DEFINED = 128;
    return Binary;
}());
Object.defineProperty(Binary.prototype, '_bsontype', { value: 'Binary' });
var UUID_BYTE_LENGTH = 16;
/**
 * A class representation of the BSON UUID type.
 * @public
 */
var UUID = /** @class */ (function (_super) {
    __extends(UUID, _super);
    /**
     * Create an UUID type
     *
     * @param input - Can be a 32 or 36 character hex string (dashes excluded/included) or a 16 byte binary Buffer.
     */
    function UUID(input) {
        var _this = this;
        var bytes;
        var hexStr;
        if (input == null) {
            bytes = UUID.generate();
        }
        else if (input instanceof UUID) {
            bytes = Buffer.from(input.buffer);
            hexStr = input.__id;
        }
        else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
            bytes = ensureBuffer(input);
        }
        else if (typeof input === 'string') {
            bytes = uuidHexStringToBuffer(input);
        }
        else {
            throw new BSONTypeError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).');
        }
        _this = _super.call(this, bytes, BSON_BINARY_SUBTYPE_UUID_NEW) || this;
        _this.__id = hexStr;
        return _this;
    }
    Object.defineProperty(UUID.prototype, "id", {
        /**
         * The UUID bytes
         * @readonly
         */
        get: function () {
            return this.buffer;
        },
        set: function (value) {
            this.buffer = value;
            if (UUID.cacheHexString) {
                this.__id = bufferToUuidHexString(value);
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns the UUID id as a 32 or 36 character hex string representation, excluding/including dashes (defaults to 36 character dash separated)
     * @param includeDashes - should the string exclude dash-separators.
     * */
    UUID.prototype.toHexString = function (includeDashes) {
        if (includeDashes === void 0) { includeDashes = true; }
        if (UUID.cacheHexString && this.__id) {
            return this.__id;
        }
        var uuidHexString = bufferToUuidHexString(this.id, includeDashes);
        if (UUID.cacheHexString) {
            this.__id = uuidHexString;
        }
        return uuidHexString;
    };
    /**
     * Converts the id into a 36 character (dashes included) hex string, unless a encoding is specified.
     */
    UUID.prototype.toString = function (encoding) {
        return encoding ? this.id.toString(encoding) : this.toHexString();
    };
    /**
     * Converts the id into its JSON string representation.
     * A 36 character (dashes included) hex string in the format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
     */
    UUID.prototype.toJSON = function () {
        return this.toHexString();
    };
    /**
     * Compares the equality of this UUID with `otherID`.
     *
     * @param otherId - UUID instance to compare against.
     */
    UUID.prototype.equals = function (otherId) {
        if (!otherId) {
            return false;
        }
        if (otherId instanceof UUID) {
            return otherId.id.equals(this.id);
        }
        try {
            return new UUID(otherId).id.equals(this.id);
        }
        catch (_a) {
            return false;
        }
    };
    /**
     * Creates a Binary instance from the current UUID.
     */
    UUID.prototype.toBinary = function () {
        return new Binary(this.id, Binary.SUBTYPE_UUID);
    };
    /**
     * Generates a populated buffer containing a v4 uuid
     */
    UUID.generate = function () {
        var bytes = randomBytes(UUID_BYTE_LENGTH);
        // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
        // Kindly borrowed from https://github.com/uuidjs/uuid/blob/master/src/v4.js
        bytes[6] = (bytes[6] & 0x0f) | 0x40;
        bytes[8] = (bytes[8] & 0x3f) | 0x80;
        return Buffer.from(bytes);
    };
    /**
     * Checks if a value is a valid bson UUID
     * @param input - UUID, string or Buffer to validate.
     */
    UUID.isValid = function (input) {
        if (!input) {
            return false;
        }
        if (input instanceof UUID) {
            return true;
        }
        if (typeof input === 'string') {
            return uuidValidateString(input);
        }
        if (isUint8Array(input)) {
            // check for length & uuid version (https://tools.ietf.org/html/rfc4122#section-4.1.3)
            if (input.length !== UUID_BYTE_LENGTH) {
                return false;
            }
            return (input[6] & 0xf0) === 0x40 && (input[8] & 0x80) === 0x80;
        }
        return false;
    };
    /**
     * Creates an UUID from a hex string representation of an UUID.
     * @param hexString - 32 or 36 character hex string (dashes excluded/included).
     */
    UUID.createFromHexString = function (hexString) {
        var buffer = uuidHexStringToBuffer(hexString);
        return new UUID(buffer);
    };
    /**
     * Converts to a string representation of this Id.
     *
     * @returns return the 36 character hex string representation.
     * @internal
     */
    UUID.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {
        return this.inspect();
    };
    UUID.prototype.inspect = function () {
        return "new UUID(\"".concat(this.toHexString(), "\")");
    };
    return UUID;
}(Binary));

/**
 * A class representation of the BSON Code type.
 * @public
 * @category BSONType
 */
var Code = /** @class */ (function () {
    /**
     * @param code - a string or function.
     * @param scope - an optional scope for the function.
     */
    function Code(code, scope) {
        if (!(this instanceof Code))
            return new Code(code, scope);
        this.code = code;
        this.scope = scope;
    }
    Code.prototype.toJSON = function () {
        return { code: this.code, scope: this.scope };
    };
    /** @internal */
    Code.prototype.toExtendedJSON = function () {
        if (this.scope) {
            return { $code: this.code, $scope: this.scope };
        }
        return { $code: this.code };
    };
    /** @internal */
    Code.fromExtendedJSON = function (doc) {
        return new Code(doc.$code, doc.$scope);
    };
    /** @internal */
    Code.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {
        return this.inspect();
    };
    Code.prototype.inspect = function () {
        var codeJson = this.toJSON();
        return "new Code(\"".concat(String(codeJson.code), "\"").concat(codeJson.scope ? ", ".concat(JSON.stringify(codeJson.scope)) : '', ")");
    };
    return Code;
}());
Object.defineProperty(Code.prototype, '_bsontype', { value: 'Code' });

/** @internal */
function isDBRefLike(value) {
    return (isObjectLike(value) &&
        value.$id != null &&
        typeof value.$ref === 'string' &&
        (value.$db == null || typeof value.$db === 'string'));
}
/**
 * A class representation of the BSON DBRef type.
 * @public
 * @category BSONType
 */
var DBRef = /** @class */ (function () {
    /**
     * @param collection - the collection name.
     * @param oid - the reference ObjectId.
     * @param db - optional db name, if omitted the reference is local to the current db.
     */
    function DBRef(collection, oid, db, fields) {
        if (!(this instanceof DBRef))
            return new DBRef(collection, oid, db, fields);
        // check if namespace has been provided
        var parts = collection.split('.');
        if (parts.length === 2) {
            db = parts.shift();
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            collection = parts.shift();
        }
        this.collection = collection;
        this.oid = oid;
        this.db = db;
        this.fields = fields || {};
    }
    Object.defineProperty(DBRef.prototype, "namespace", {
        // Property provided for compatibility with the 1.x parser
        // the 1.x parser used a "namespace" property, while 4.x uses "collection"
        /** @internal */
        get: function () {
            return this.collection;
        },
        set: function (value) {
            this.collection = value;
        },
        enumerable: false,
        configurable: true
    });
    DBRef.prototype.toJSON = function () {
        var o = Object.assign({
            $ref: this.collection,
            $id: this.oid
        }, this.fields);
        if (this.db != null)
            o.$db = this.db;
        return o;
    };
    /** @internal */
    DBRef.prototype.toExtendedJSON = function (options) {
        options = options || {};
        var o = {
            $ref: this.collection,
            $id: this.oid
        };
        if (options.legacy) {
            return o;
        }
        if (this.db)
            o.$db = this.db;
        o = Object.assign(o, this.fields);
        return o;
    };
    /** @internal */
    DBRef.fromExtendedJSON = function (doc) {
        var copy = Object.assign({}, doc);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new DBRef(doc.$ref, doc.$id, doc.$db, copy);
    };
    /** @internal */
    DBRef.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {
        return this.inspect();
    };
    DBRef.prototype.inspect = function () {
        // NOTE: if OID is an ObjectId class it will just print the oid string.
        var oid = this.oid === undefined || this.oid.toString === undefined ? this.oid : this.oid.toString();
        return "new DBRef(\"".concat(this.namespace, "\", new ObjectId(\"").concat(String(oid), "\")").concat(this.db ? ", \"".concat(this.db, "\"") : '', ")");
    };
    return DBRef;
}());
Object.defineProperty(DBRef.prototype, '_bsontype', { value: 'DBRef' });

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = undefined;
try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(
    // prettier-ignore
    new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
}
catch (_a) {
    // no wasm support
}
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
/** A cache of the Long representations of small integer values. */
var INT_CACHE = {};
/** A cache of the Long representations of small unsigned integer values. */
var UINT_CACHE = {};
/**
 * A class representing a 64-bit integer
 * @public
 * @category BSONType
 * @remarks
 * The internal representation of a long is the two given signed, 32-bit values.
 * We use 32-bit pieces because these are the size of integers on which
 * Javascript performs bit-operations.  For operations like addition and
 * multiplication, we split each number into 16 bit pieces, which can easily be
 * multiplied within Javascript's floating-point representation without overflow
 * or change in sign.
 * In the algorithms below, we frequently reduce the negative case to the
 * positive case by negating the input(s) and then post-processing the result.
 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
 * a positive number, it overflows back into a negative).  Not handling this
 * case would often result in infinite recursion.
 * Common constant values ZERO, ONE, NEG_ONE, etc. are found as static properties on this class.
 */
var Long = /** @class */ (function () {
    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     *
     * Acceptable signatures are:
     * - Long(low, high, unsigned?)
     * - Long(bigint, unsigned?)
     * - Long(string, unsigned?)
     *
     * @param low - The low (signed) 32 bits of the long
     * @param high - The high (signed) 32 bits of the long
     * @param unsigned - Whether unsigned or not, defaults to signed
     */
    function Long(low, high, unsigned) {
        if (low === void 0) { low = 0; }
        if (!(this instanceof Long))
            return new Long(low, high, unsigned);
        if (typeof low === 'bigint') {
            Object.assign(this, Long.fromBigInt(low, !!high));
        }
        else if (typeof low === 'string') {
            Object.assign(this, Long.fromString(low, !!high));
        }
        else {
            this.low = low | 0;
            this.high = high | 0;
            this.unsigned = !!unsigned;
        }
        Object.defineProperty(this, '__isLong__', {
            value: true,
            configurable: false,
            writable: false,
            enumerable: false
        });
    }
    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits.
     * Each is assumed to use 32 bits.
     * @param lowBits - The low 32 bits
     * @param highBits - The high 32 bits
     * @param unsigned - Whether unsigned or not, defaults to signed
     * @returns The corresponding Long value
     */
    Long.fromBits = function (lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    };
    /**
     * Returns a Long representing the given 32 bit integer value.
     * @param value - The 32 bit integer in question
     * @param unsigned - Whether unsigned or not, defaults to signed
     * @returns The corresponding Long value
     */
    Long.fromInt = function (value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if ((cache = 0 <= value && value < 256)) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
                UINT_CACHE[value] = obj;
            return obj;
        }
        else {
            value |= 0;
            if ((cache = -128 <= value && value < 128)) {
                cachedObj = INT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = Long.fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
                INT_CACHE[value] = obj;
            return obj;
        }
    };
    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @param value - The number in question
     * @param unsigned - Whether unsigned or not, defaults to signed
     * @returns The corresponding Long value
     */
    Long.fromNumber = function (value, unsigned) {
        if (isNaN(value))
            return unsigned ? Long.UZERO : Long.ZERO;
        if (unsigned) {
            if (value < 0)
                return Long.UZERO;
            if (value >= TWO_PWR_64_DBL)
                return Long.MAX_UNSIGNED_VALUE;
        }
        else {
            if (value <= -TWO_PWR_63_DBL)
                return Long.MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
                return Long.MAX_VALUE;
        }
        if (value < 0)
            return Long.fromNumber(-value, unsigned).neg();
        return Long.fromBits(value % TWO_PWR_32_DBL | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
    };
    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @param value - The number in question
     * @param unsigned - Whether unsigned or not, defaults to signed
     * @returns The corresponding Long value
     */
    Long.fromBigInt = function (value, unsigned) {
        return Long.fromString(value.toString(), unsigned);
    };
    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @param str - The textual representation of the Long
     * @param unsigned - Whether unsigned or not, defaults to signed
     * @param radix - The radix in which the text is written (2-36), defaults to 10
     * @returns The corresponding Long value
     */
    Long.fromString = function (str, unsigned, radix) {
        if (str.length === 0)
            throw Error('empty string');
        if (str === 'NaN' || str === 'Infinity' || str === '+Infinity' || str === '-Infinity')
            return Long.ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            (radix = unsigned), (unsigned = false);
        }
        else {
            unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        var p;
        if ((p = str.indexOf('-')) > 0)
            throw Error('interior hyphen');
        else if (p === 0) {
            return Long.fromString(str.substring(1), unsigned, radix).neg();
        }
        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = Long.fromNumber(Math.pow(radix, 8));
        var result = Long.ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = Long.fromNumber(Math.pow(radix, size));
                result = result.mul(power).add(Long.fromNumber(value));
            }
            else {
                result = result.mul(radixToPower);
                result = result.add(Long.fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    };
    /**
     * Creates a Long from its byte representation.
     * @param bytes - Byte representation
     * @param unsigned - Whether unsigned or not, defaults to signed
     * @param le - Whether little or big endian, defaults to big endian
     * @returns The corresponding Long value
     */
    Long.fromBytes = function (bytes, unsigned, le) {
        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    };
    /**
     * Creates a Long from its little endian byte representation.
     * @param bytes - Little endian byte representation
     * @param unsigned - Whether unsigned or not, defaults to signed
     * @returns The corresponding Long value
     */
    Long.fromBytesLE = function (bytes, unsigned) {
        return new Long(bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24), bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24), unsigned);
    };
    /**
     * Creates a Long from its big endian byte representation.
     * @param bytes - Big endian byte representation
     * @param unsigned - Whether unsigned or not, defaults to signed
     * @returns The corresponding Long value
     */
    Long.fromBytesBE = function (bytes, unsigned) {
        return new Long((bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7], (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3], unsigned);
    };
    /**
     * Tests if the specified object is a Long.
     */
    Long.isLong = function (value) {
        return isObjectLike(value) && value['__isLong__'] === true;
    };
    /**
     * Converts the specified value to a Long.
     * @param unsigned - Whether unsigned or not, defaults to signed
     */
    Long.fromValue = function (val, unsigned) {
        if (typeof val === 'number')
            return Long.fromNumber(val, unsigned);
        if (typeof val === 'string')
            return Long.fromString(val, unsigned);
        // Throws for non-objects, converts non-instanceof Long:
        return Long.fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
    };
    /** Returns the sum of this and the specified Long. */
    Long.prototype.add = function (addend) {
        if (!Long.isLong(addend))
            addend = Long.fromValue(addend);
        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xffff;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xffff;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xffff;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xffff;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xffff;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xffff;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c48 += a48 + b48;
        c48 &= 0xffff;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };
    /**
     * Returns the sum of this and the specified Long.
     * @returns Sum
     */
    Long.prototype.and = function (other) {
        if (!Long.isLong(other))
            other = Long.fromValue(other);
        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    /**
     * Compares this Long's value with the specified's.
     * @returns 0 if they are the same, 1 if the this is greater and -1 if the given one is greater
     */
    Long.prototype.compare = function (other) {
        if (!Long.isLong(other))
            other = Long.fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        // At this point the sign bits are the same
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return other.high >>> 0 > this.high >>> 0 ||
            (other.high === this.high && other.low >>> 0 > this.low >>> 0)
            ? -1
            : 1;
    };
    /** This is an alias of {@link Long.compare} */
    Long.prototype.comp = function (other) {
        return this.compare(other);
    };
    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or unsigned if this Long is unsigned.
     * @returns Quotient
     */
    Long.prototype.divide = function (divisor) {
        if (!Long.isLong(divisor))
            divisor = Long.fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');
        // use wasm support if present
        if (wasm) {
            // guard against signed division overflow: the largest
            // negative number / -1 would be 1 larger than the largest
            // positive number, due to two's complement.
            if (!this.unsigned &&
                this.high === -0x80000000 &&
                divisor.low === -1 &&
                divisor.high === -1) {
                // be consistent with non-wasm code path
                return this;
            }
            var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
            return Long.fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (this.isZero())
            return this.unsigned ? Long.UZERO : Long.ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(Long.MIN_VALUE)) {
                if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE))
                    return Long.MIN_VALUE;
                // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(Long.MIN_VALUE))
                    return Long.ONE;
                else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shr(1);
                    approx = halfThis.div(divisor).shl(1);
                    if (approx.eq(Long.ZERO)) {
                        return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;
                    }
                    else {
                        rem = this.sub(divisor.mul(approx));
                        res = approx.add(rem.div(divisor));
                        return res;
                    }
                }
            }
            else if (divisor.eq(Long.MIN_VALUE))
                return this.unsigned ? Long.UZERO : Long.ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative())
                    return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            }
            else if (divisor.isNegative())
                return this.div(divisor.neg()).neg();
            res = Long.ZERO;
        }
        else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned)
                divisor = divisor.toUnsigned();
            if (divisor.gt(this))
                return Long.UZERO;
            if (divisor.gt(this.shru(1)))
                // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return Long.UONE;
            res = Long.UZERO;
        }
        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2);
            var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
            var approxRes = Long.fromNumber(approx);
            var approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = Long.fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }
            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero())
                approxRes = Long.ONE;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };
    /**This is an alias of {@link Long.divide} */
    Long.prototype.div = function (divisor) {
        return this.divide(divisor);
    };
    /**
     * Tests if this Long's value equals the specified's.
     * @param other - Other value
     */
    Long.prototype.equals = function (other) {
        if (!Long.isLong(other))
            other = Long.fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };
    /** This is an alias of {@link Long.equals} */
    Long.prototype.eq = function (other) {
        return this.equals(other);
    };
    /** Gets the high 32 bits as a signed integer. */
    Long.prototype.getHighBits = function () {
        return this.high;
    };
    /** Gets the high 32 bits as an unsigned integer. */
    Long.prototype.getHighBitsUnsigned = function () {
        return this.high >>> 0;
    };
    /** Gets the low 32 bits as a signed integer. */
    Long.prototype.getLowBits = function () {
        return this.low;
    };
    /** 
        return this.highRes.isZero())
                approxR          anode).div(divisor).neg();
        1         rem = this.sLong.prots.hw & 0xffff;
     its = f)T Lonsit    4(ivisorgit or
   's 0 if they are tlurns T.div(divisor).neg();
        1g1v(dikT.div(divi/gnexffff;
   _ thg.prots.hw & 0xffff;
     its = f)T Lonsit    4(ivisorgit or
   rn this.hiIing  are   4( 4(row;
    };
    /** This is aMol this.heturn this.
        );
  nterio)exffff;
      if (thisNeg gned();
            if (divisor.gt(this))
     otypW=ecrnts = f)T       other = Long.frLf a valu x.
  reI_ other))
            otherI_ ot    ve()) {
                if (divisor.isN      Lox80;
  };
   tyLog.O   if (ypW=ecrnts =uc      other = Long.fromValue(other);
    4, 132, 32, 2, 173, 32, 3 ret  /*n Long.fromString(val,.di   -);
ther))
 e   rn Loncrnts = f)[5] <Nrinnd;
    l3ns.leg*n Long.fro2 bitBrox. herCs.hUINT_u)[5nction (other) {
        if (!Long.isLong(other))
            other = Long.fromValue(other);
        if (this.eq(other))
            returring(o    ifs of  ifstle ch h doc.$binary === 'ster rn mf ('$uunverts the specified value   ntil    /**   rntsc(thing(other) 16) | c00, (c48 << 16) | c&      retu    * Creates a Long from its big end    retu  Lng(othO by cpN retrrE : Longrnary =0, (Long(other))
            3 ret  /*n Long.   rnts =uis.higsFf (Ny// omBytesBE(chever i(dtio[   grnary =0, (Long(other))
            3 ret  /*n Long.   rnts =uis.wa Long.other !   g(othnarUd ilog2 = (type = Math.ceil(Math.log(approx) / Math.LN2);
      Math if = ig enSpe = Math.ceilrUd i /**0 {
                if (ding }
 .r.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2);
          ns 
      alu x.
  reI_ other))
specesow Ra5     ceil(Mat.LN2ts =uis.wf.wf.(urn Llike yeI_ ot(Mat127, 1, 1   * - Loc00, (* - Loc00, (* - L   i   Tiv(d?          ath ();
 add if at least add if at leastleast ad a valu x.least ad i(dtio[   is.wf.wf.(urn Llike    aeast ad n(Math.lw R** Gets thedTt ad 
         number into 4 chunks of 16 bits, and then sum the chunks.
        var a48 = this.high >>> 16;
        var a32 = this.high   /*n << 16)a vaa vaa y R** Gets log2 = 3pevar 
  reI_, {vaa y R** Gets lo Lli umber into 4   }
          t ad n(Math.l, c16 = 0, c00 = 0;
 pot(MatrghRemStringT0;
 umbe_ecrnt (* -og2 e0;
 chur 
  reI_,R**+rnts 0 {





















+n Loi -);
t>>> 16;
      if (divisor.gt(this))
     otypW=
   li S?l.ins>> 31 === 1)
 unsirnt;
t>>> 16;
      if (divisor.gt(this))
     otypW=
   li S   4, 132, 32, 2, 173, 32, 3 ret  | c&// We know prototype.andot(MvtIvaa vaa y cg 2, pe.and(Math (* oOI5ast now prototype.andot(MvtIvaa vaa y csor)nt-Ivaa vaa ototype.andot       ifbnu << 1ld cause
       = dion  | c&// We kOlype.andot ow prototype.andot(MvtI}
      dion fun    li umb vaaceil a16 + b16;
  Buffer.from(input.buffequalt(Ma/xI : 's.low;
    };
    /** 
   dion ch s (* -    if (   '  /*f =n8-th diging.ZERO)) {
 rring(o  (divisorRepplong.allBuffer.from(inike    aeas.eq(other))
            returring(o    ifs of  ifstle ch h doc.$bin    returring(o    ifsUike          res = res.a6eturn -1;
-e cS.$bin    returCNe.il(Mat.LN2ts =uis.wf.wf.(urn Llike yeI_ ot(Mat127,pro$sETUo$sETUo$sETUoRd=uis.wf.ws.wf.ws.wf.bleast ad a va check specially whetht handling thisv, (c48 << 16) | c&      retu    * Creates a Long fves aspeO7r1)
     etu >>> 0;
  tht g2 e0;  li etu(   kp* Creates a Lon    HoE.toe0; the approxa Lo   .a6eturn -1;
-e ce   4( 4(:speO7r1)
yc48& 0xffff(gli etu( "C 4( 4(:speO7dally whetht hkp*d   n -1;
-e ce   4( 4(:speO7rid into it)
 e recus^0 great*d   n - Long doc.$b1 g2t hk+ng(t)
 Res.isZ

/*dt)
 e recu  it  return Long.fromString(str.substring(1),.substr or chann LcisZ

/)totypLplt by chan** nstri a6etur.fromStringy7r1_VALUE)) {cu  it itanceof Long))
            Neturn this.high;
    };
    /** Gets the high/** Gets the Rput) {
   lue(other);
        if (this.eq(other))
   {c    ifsUik - Lthishkp*d  he m   lturn isObjectLiO_PWR_ this.low;
    };
    /** 
        return this.hig16) | c00* 
A
    }eO7r1)
yc4};
    /** 
        return Lon too      Neturn this.high;
    };
    s.hing(o    ihat i3oed) {
 n this.h  if = Loa va     ree ce   4(   - Lthishkp*dspecdtio[* 
    Pvik - Lthishkp*126,?this. >>> 0 |ally whetht hkp*d   n -1;
-e ce   acy whetht hkp*d   n -1;
-e ce   acy whetht hkp*d   (* -   ;l  /*n Long   curn Long.fromBits(low, wasm.get_high(Llike yeI_ ot(Mat127hisv,S f)T     1)
y lue(other);
        if (thisturring(o    ifat127hisv,S fcu  it  retu Long frmt is signe     1)
yow, wasm.gch h deLongal.uns Long.ONEh h dions below fo 0ill tfrmt C }eO7r1)
ycdeL h dio/ fl  return 0;eO7r1)
ycdeL h dio/ fl  return 0;eO7r1)
ycdeL h dio/ fl  return 0;eO7r1)
yc , (c48ong fves adO : return 0;r hkp*d   hkp*d   n -1;
-e ce tcs(o (c4e approue, (etr0;eO7r1)
O|Eh h dions below fo 0ill tfrmt C }ekp*d   hk|Eh 

/*dt)
 e recu  it  return L   if (ca|Eh h dions below freturn L   if * @rerecu  it  return L   if (ca|Eh h diis.h(diw === if (ca|Eh s.elhSm      var aHE = {};
/** A cache of the Long representations ons belecu  it  return L:r('e(dt)
 e recu  it  , 3 mrecu  it  , 3 mrrn tlecu  ite Lenw prototypeT"ce the negatiC    BNlikDw === if (c HoE.toe0; th  - Lthishkp
     * Co  Object.(ot5  ikDw === if (c HoE.toe0; th  - LthishkpertiCd) hex strbfthishkpertiCd) hex os.h(dO==  ite Lenw pr-=ui/** rep   hkp*en LcisZ

/)totyeturn L   R   r-Pvik -

/)toetup os.h(dO=as.eq(other))    .isLonow fo 0 h d -e ce   ar-Pisor.neg());
 0 h d -e*0 {dt)
 e recu  it  return L   if (ca|Eh h dions below fret  ltur (ca|Eh s.- Lthishkpu  it  -Pisor.negf.ws.ionsmtiCd) innig16) | c00urn isObjeurn4!onsmt.wf= 1)
 @linimpare} */
l_ hk+ng(t)nctioepresentations ons belecud  '  /3 mu  it  return L:r('e(dt)
 e   .wf&      retu    * Creates a Long ce the negatiC   iC   iC   iCtotype.;                return divisor.isNeg[  /3l = ype.;     (value >= TWO_PWR_64_DBL)
   tionscinimpare} */
l_ hk+ng(t)nctioepresor s/** 
his.divR** var areturn L:r('e(d -);Mthis.n etu,fromNume n  ikDw === if (c Ho.isN   ctual valuMthscinin et pop_lse,
       s reisor.eq(L   hkp*d   n -1;
-e ce tcs(o (c4e nsigned()w = Gher);
       */
lsN   etu,fromNume nior hyWR_32    otherI_ ot    veR_32    otherI_ ot   written  = ype.;     (isoc.$b1 g2t hk+ngs))is))
     
l_9 thisrn L2t h[e32   e bits of ad 
     L2t h[e32   e br('e(d d  itn it oc.$b1 g2t heng or Buff (ippruns Long.ONEh h dions below fo 0ill tfrmt C }eO7r1)
ycdeL h dio/ fl  return 0;eO7r1)
ycdeL h dio/ fl  return 0;eO7r1)
ycdeL h dio/ fl  return 0;eO7r1)
yc , (c48ong5k|Eh- diOox,elow fo 0r-Pow &igFdiOox,er1)
it0 fo 0ill }ict0 fo 0illo thtisor.eq(L   hkp*d   n -1;
-e ce g5k|Eh-e 
  Oox,y         varherI_ ot   written  = ype.;     (isoc.$bH if _ obelow fo 0ill tesult by changing it in the 48-th digit or
          lt Oox,hanging i        rb obelo|        nr
          ltingfIs));
 0g itions BltingfIs)); (c48ong5k|Eh- diOelo|turnngin(str.sturn L trghR-th ;   ee.h- d  nrd) {
) / divisos]totype0k|E   ng5k|Ehision d  L2t h[e32   e g5k|Eh- d}_O7r1eHo.isN   c e g5k|Eh- d}.isN   c e g5k|Eh5  itotype  L2g    oR-th ;  i.digig[  /3l = ype.;     (val<ks      lo/ |Eh- d}.isN   ltingfIs)); (c endian byte peO7rid itUUID(\"".concm> 31 === 1)
 unsirnt;
t>>> Ink|Eh- G d  | str === 'o= f)     .ceil(Math.log(approx) / Math.LN2)SfIs)+.high ==.{vaa!6{ik  hk 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1      if (str.length N;
 o, 1      ied i-167,isoc./eR_g5k| if (stil(M0 (stil(M 
-eICtotype.anEx. herCs.s ==0dio/ fl  rridl1  Math.lb1 g2tng frmt is signe     1)
yow, wasm.gch h d7, 3]))i2tngt hk+ngval<ks(\"".concm> 31 === 1)
 unsirnt;
t>>> Ink|El/eR_g5khk+ngval<ks(\"".colnk|Eh- /eR_g5khk+ngval<ks(h.lb1(5k| if (stil(M0 (stil(M 
-eI 167,' Co  Ok| l  rridl1  Math.lb1 g2tng frmt io(Ma/xI : 's.low;
    };
    stion     f (stil(M0ar aHE = {};f (divisor.eq(Long.MIN_VALUE))
                    ret(Ma/xIn    ath.LN2a/xIn   rLf a valu x.
  reI_ other))
            otherI_ ot    ve()) {
                if (diviso<sn] = oe   e  eet_higgh ynw pher);}e rec;
    return Lokp*d f (dO|Eh       oe   e  eet_higgh ynw   };
  tingfIs)); (c endiE(sti inow*,7,' Co  Ok| l  rridl1  Math.lb
   tionsci) / SON = fu        ,' Coy?hsti inow*lb
linow*,w*lt hk+ngs))is))
     
l_9sfw R** Gets theheO7lb
l.aHE = {}sfw t))
     
l_9sfw R** Gets tion.slb
 of ad 
     L2t h[e32   e br('el }eets MatholsNegative() ? -1 eat*d*nMathol3o/w Rots MathrI_ ot    ve()) {
                if (diviso<sn] = oe   e  eet_higgh ynw pher);}e rec;
    return Lokp*d f (dO|Eh       oe   e  eet_higgh ynw   };
  tingfIs)); (c endiE(-VCteger nw   };
  tingfIs)); ((c  oe   e  eet_higgh yEh       oe   ngval<ks(et_highval, unsigned) {n.slb
 of ad 
     L2t h[e32   edentil('__isLongdas.eq(othensigned) {n.slb
 of ag5k|Eh5  Cteger neerI_ ot    ve()) {
                if (diviis.db = dgvah (signeive()eet_hi N;-Ctege{n.slb
 o4high4i1atholsNegative()// guard eturn           / fl  ret] N;%Ry n guard o et.surn       t*d f iive()/eet ad i(dtio[   is.wf.wf.else {
  ()) {
  A(dtiCvarhetio[   =iis.dbgative(  if it in the    t    ve()) {
  k  / f2t i, 11, 1ram unn        g.ZERO;
        for (var i= fus3
     
l_9sfw R** Gets theheOM     if (diviso<sn]  = dg  =ielse a Long ce the negatiC   iC   iC   iCtotf (diviso<sn]  = d.lb1 g2ns   iC   iC   iCtotf (diviso<sn]  =l }eets Mturn 0;eO7r1)
ycdeL h 1;
-e co two's com|t the
    aeas
epresor s/** 
hisfe   LonLong.gion.slb
 of     (isockinto 4 csorgit or
   's 0 ifen  =a     ree2onLogdas.eq(othgs))sent    t  returCg fves afto 4 csorgit or (isgs)sssssssseons bevaa// gusss3)
yowt is criti; (c endiE(-VCtegh >>> 0 > this.h** 
(stil(M 
-eI 167,' Co  Ok| l  rridl1  Math.lb1 g2(Logdas.eq,w*lte   nw3 is criti; (c endiE(-VCtegh >>> 0 > this.h** 
(stil(M 
-eI 167,' Co  Ok| l  rridl1  Math.lb1 g2(Logdas.eq,w*lte   nw3 is criti; (c endiE(-VCtegh >>> 0 > this.h** 
(stil(M 
-eI 167,' Co  Ok|iive i=ml1  Mail(M 
-eI 167,' Co  Ok| lLogda ve()) {** @    rb obelo|        nr
          l          l      l  slint-disablev wasm.   // ce U   iCa_/   l  endiE(-VCtegpail(M 
-t oc.$b1  ynw')1beloseons beDCa_/   l sigeeer);
        if (thisturring(o    ifat127hisv,S fcu  it  retu Long frmt is signe     1)
yow 167,' C= furee2oni vapttu Lgwf.(n Lnternal * Long = ype.;      d  retuyow 167,' C= furee2t1  Mail(M 
uree2t1 d =es ' C= fureeO;
                return Lokprov,S fcu  it  retu Long 8iC      rb obeloL2t h[e32   e g5e   ipeO             ver bebelo|    aeas
sent    t  returCg fves afto 4 csorgit or  h[e32   e 2t h[e afto 4 csorgi    tn Lfto i  eet_higgh ynw   };
  tingfIs)); (c _ ot    ve_higglow d= furee2t    veyhigh